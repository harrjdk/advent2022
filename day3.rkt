#lang racket
(define input (file->string "day3.txt"))
;; now let's run through the entire input after splitting it into lines
(define inlines (string-split input #rx"\r?\n"))
;; (println inlines)
;; (println (map string->list inlines))
(define linelengths (map string-length inlines))
;; (println linelengths)
(define valuetable (make-hash))
(hash-set! valuetable #\a 1)
(hash-set! valuetable #\b 2)
(hash-set! valuetable #\c 3)
(hash-set! valuetable #\d 4)
(hash-set! valuetable #\e 5)
(hash-set! valuetable #\f 6)
(hash-set! valuetable #\g 7)
(hash-set! valuetable #\h 8)
(hash-set! valuetable #\i 9)
(hash-set! valuetable #\j 10)
(hash-set! valuetable #\k 11)
(hash-set! valuetable #\l 12)
(hash-set! valuetable #\m 13)
(hash-set! valuetable #\n 14)
(hash-set! valuetable #\o 15)
(hash-set! valuetable #\p 16)
(hash-set! valuetable #\q 17)
(hash-set! valuetable #\r 18)
(hash-set! valuetable #\s 19)
(hash-set! valuetable #\t 20)
(hash-set! valuetable #\u 21)
(hash-set! valuetable #\v 22)
(hash-set! valuetable #\w 23)
(hash-set! valuetable #\x 24)
(hash-set! valuetable #\y 25)
(hash-set! valuetable #\z 26)
(hash-set! valuetable #\A 27)
(hash-set! valuetable #\B 28)
(hash-set! valuetable #\C 29)
(hash-set! valuetable #\D 30)
(hash-set! valuetable #\E 31)
(hash-set! valuetable #\F 32)
(hash-set! valuetable #\G 33)
(hash-set! valuetable #\H 34)
(hash-set! valuetable #\I 35)
(hash-set! valuetable #\J 36)
(hash-set! valuetable #\K 37)
(hash-set! valuetable #\L 38)
(hash-set! valuetable #\M 39)
(hash-set! valuetable #\N 40)
(hash-set! valuetable #\O 41)
(hash-set! valuetable #\P 42)
(hash-set! valuetable #\Q 43)
(hash-set! valuetable #\R 44)
(hash-set! valuetable #\S 45)
(hash-set! valuetable #\T 46)
(hash-set! valuetable #\U 47)
(hash-set! valuetable #\V 48)
(hash-set! valuetable #\W 49)
(hash-set! valuetable #\X 50)
(hash-set! valuetable #\Y 51)
(hash-set! valuetable #\Z 52)
(define (compartmentalize inp)
  (let* ([stringlength (string-length inp)]
         [halflength (/ stringlength 2)]
         [compartment1 (string->list (substring inp 0 halflength))]
         [compartment2 (string->list (substring inp halflength))]
         [common (set-intersect compartment1 compartment2)])
    (apply + (map (lambda (x) (hash-ref valuetable x 0)) common))))
(define priorities (map compartmentalize inlines))
;; (println priorities)
(define totalpriority (apply + priorities))
(println totalpriority)
;; part 2: need to get 3 line groupings
;; split into groups of three with a new function
(define (splitup in)
  (if (empty? in) '()
      (let ([firstgroup (take in 3)]
            [rest (drop in 3)])
        (cons firstgroup (splitup rest)))))
(define groupings (splitup inlines))
;;(println groupings)
;; now let's more or less repeat our first half
(define (badgepriority in)
  (let ([group1 (string->list (car in))]
        [group2 (string->list (cadr in))]
        [group3 (string->list (caddr in))])
    (apply + (map (lambda (x) (hash-ref valuetable x 0)) (set-intersect group1 group2 group3)))))
(define grouppriorities (map badgepriority groupings))
;; (println grouppriorities)
(println (apply + grouppriorities))